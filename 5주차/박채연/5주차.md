### SSL 인증서와 Nginx

<img width="655" height="409" alt="스크린샷 2025-08-13 오후 5 34 23" src="https://github.com/user-attachments/assets/41d04b24-e787-4d3b-97c2-ef2e65c344d0" />

1. **외부 요청 수신:** 사용자가 도메인(`https://your-domain.com`)으로 보낸 요청이 DNS를 거쳐 받은 IP 주소로 EC2 인스턴스( 가상 하드웨어 )에 도착하면, 웹서버 프로그램인 nginx가 먼저 받습니다.
2. **내부 통신:** Nginx는 받은 요청을 처리하기 위해 **EC2 인스턴스 내부의** `localhost:8080` 주소로 요청을 다시 보냅니다. ( Nginx의 리버스 프록시 )
3. **애플리케이션 처리:** EC2 인스턴스 안의 8080번 포트에서 실행 중이던 실제 웹 애플리케이션이 이 내부 요청을 받아서 처리합니다.

EC2 내부에 SSL 인증서를 설치하여 사용자 브라우저 <--- (HTTPS) ---> Nginx가 암호화된다.

### 정리

- **사용자:** `https://divary.app/api`로 요청
- **DNS:** `divary.app`의 IP 주소(예: `15.125.23.214`)를 알려줌
- **브라우저:** `https://15.125.23.214/api`로 요청 (HTTPS는 443 포트)
- **Nginx (in EC2):** 443 포트로 들어온 요청을 받아서 SSL 암호화를 해제
- **Nginx (리버스 프록시):** 요청을 내부의 `localhost:8080`으로 전달
- **스프링 앱 (in EC2):** 8080 포트에서 요청을 받아 처리 후 Nginx에게 응답
- **Nginx -> 사용자:** 응답을 다시 암호화해서 사용자에게 최종 전달

### 단일 서버
<img width="668" height="405" alt="스크린샷 2025-08-13 오후 5 34 43" src="https://github.com/user-attachments/assets/26d3fa41-5f47-42e4-8774-f815e7919407" />

### 사용자의 요청 처리 흐름

1. 사용자는 도메인 이름을 통해 → DNS 서버에 질의한 뒤  → IP 주소를 반환 받는다.
2. 해당 IP 주소로 HTTP 요청이 전달된다.
3. 요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.

### 데이터베이스
<img width="683" height="437" alt="스크린샷 2025-08-13 오후 5 35 15" src="https://github.com/user-attachments/assets/f825aea4-71c9-4255-a5d5-5531ad038924" />

### 어떤 데이터 베이스를 선택할 것인가?

1. 관계형 DB ( 열, 칼럼, SQL을 사용하여 조인 가능 )
2. 비관계형 DB ( 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소, 일반적으로 조인 지원 x )

→ 비관계형 DB가 바람직한 선택일 수 있는 상황들

1. 아주 낮은 응답 지연시간이 요구됨
2. 다루는 데이터가 비정형
3. 데이터를 직렬화하거나 역직렬화할 수 있기만 하면 됨
4. 아주 많은 양의 데이터를 저장할 필요가 있음
5. 대규모 데이터 처리, 빠른 데이터 처리

→ 관계형 DB가 바람직한 선택일 수 있는 상황들

1.  데이터의 무결성과 일관성이 중요한 경우, 복잡한 쿼리를 자주 사용하는 경우

 프로젝트의 특성과 요구사항을 정확히 파악하고, 장단점을 고려하여 적절한 데이터베이스 기술을 선택하는게 좋다.

### 수평적 확장 수직적 확장

사양을 올리는 스케일 업, 수직적 규모 확장은 트래픽의 양이 적을땐 좋은 선택이지만, 장애에 대한 자동복구나 다중화 방안을 제시하지 않는다, 또한 CPU나 메모리를 무한대로 증설하긴 한계가 있다.

너무 많은 사용자의 접속으로 인한 웹 서버 한계 상황을 해결하기 위해 부하 분산기 또는 로드밸런서를 도입하는 것이 최선이다.

### 로드밸런서
<img width="671" height="527" alt="스크린샷 2025-08-13 오후 5 35 42" src="https://github.com/user-attachments/assets/9a8d4087-954e-400a-9ebd-949fb2b1ea69" />

### 사용자의 요청 처리 흐름

1. 사용자는 로드밸런서 공개 IP 주소로 접속한다
2. 로드 밸린서는 웹 서버와 통신하기 위해 인터넷으로 접속이 불가능한 같은 네트워크에 속해야지 쓸 수 있는 사설 IP 주소를 사용한다.
3. 수평적 확장 즉, 다중 서버를 두는 방식으로 서버 1이 다운돼도 트래픽을 서버2로 전송할 수 있어 웹 계층의 가용성이 향상된다.

### 데이터베이스 다중화

데이터 베이스 다중화는 보통 서버 사이 주-부 관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식을 사용한다.

insert,update,delete 등의 쓰기 연산은 주 서버에서만 지원한다. 부 데이터베이스는 그 사본을 전달 받으면 읽기 연산만을 지원한다.
<img width="669" height="634" alt="스크린샷 2025-08-13 오후 5 36 02" src="https://github.com/user-attachments/assets/c9c1e752-3bdb-43ce-9132-790aec16b492" />

대부분의 어플리케이션은 read >> write 연산이라, 통상 부 데이터베이스 수가 주 데이터베이스 수보다 많다. 

### 데이터 베이스 다중화의 장점

1. 읽기 연산은 부 데이터 베이스 서버들로 분산되므로 병렬 처리될 수 있는 쿼리의 수가 늘어나, 성능이 좋아진다.
2. 자연재해 등의 이유로 데이터 베이스 서버가 파괴되어도 지역적으로 떨어진 위치에 다중화 시켜 놓을 수 있기에 데이터는 보존된다.
3. 데이터의 가용성이 향상된다.

만약 부 데이터 베이스가 다운되면, 한대뿐인 경우 주 데이터베이스가 읽기 연산을 한시적으로 맡게 되고 , 부 데이터 베이스다 여러대인 경우는 다른 부 데이터베이스가 장애 서버를 대체할 것이다.

만약 주 데이터 베이스가 다운되면, 부 데이터 베이스가 한시적으로 주 서버가 될 것이다. 하지만, 이 경우 부 데이터 베이스는 데이터가 최신 상태임이 보장되지 않기 때문에 복구 스크립트나, 다중 마스터, 원형 다중화 방식을 통해 해결될 수 있다. ( 이 방식들에 대한 소개는 책에 나와 있지 않다. )

<img width="674" height="638" alt="스크린샷 2025-08-13 오후 5 36 23" src="https://github.com/user-attachments/assets/2d181277-06f8-480e-b418-b91fb889ef35" />

### 사용자의 요청 처리 흐름

1. DNS로 부터 로드밸린서와 도메인의 IP주소를 받는다.
2. 사용자는 로드밸린서 IP 주소로 접속한다.
3. 해당 요청은 다중 서버중 한 곳에 전달된다.
4. 웹 서버는 사용자의 데이터를 부 데이터 베이스 서버에서 읽는다.
5. 변경된 데이터는 주 데이터베이스로 전달한다.

### 응답 시간을 줄이는 방법 - 캐시, CDN

- 응답 시간은 캐시를 붙여 줄인다.
- 정적 콘텐츠는 CDN으로 옮긴다.

웹페이지를 새로고침할때마다 데이터를 가져오기 위해선 데이터베이스를 여러번 호출해야한다.

데이터 베이스 호출 빈도수를 줄이기 위해, 캐시를 둔다. 캐시 서버를 사용하기 위해 제공하는 API 를 사용한다.
<img width="692" height="174" alt="스크린샷 2025-08-13 오후 5 36 38" src="https://github.com/user-attachments/assets/65b9539e-8fb4-438c-9a28-03019e841089" />

### 캐시 사용시 고려할 사항

- 데이터 갱신은 빈번하지 않지만, 참조가 빈번하게 일어나는 경우 캐시 도입
- 캐시는 휘발성 메모리를 사용하므로, 영속적으로 보관할 데이터를 캐시에 X
- 캐시의 만료 정책
- 저장소 원본의 갱신과 캐시 갱신이 단일 트랜잭션으로 처리되지 않는 경우 일관성이 깨질 수 있음
- 캐시 서버를 한대만 두는 경우, SPOF 가 발생할 수 있다.
- 캐시 메모리의 크기 ( 너무 작으면, 매번 데이터가 밀려나 의미 없어질 수 있다 )
- 데이터 방출 정책 LRU, FIFO

### CDN - 정적 콘텐츠 캐싱
<img width="664" height="241" alt="스크린샷 2025-08-13 오후 5 36 52" src="https://github.com/user-attachments/assets/e69dfb93-00b1-4bf7-a722-299b921d229c" />

### 고려할 점

- CDN은 제 3사업자에 의해 운영되므로, 들어가고 가는 데이터 전송양에 따라 요금을 낸다. 자주 사용되는 콘텐츠만 캐싱하자.
- 적절한 만료시간
- CDN이 죽을 경우 웹이나 앱이 어떻게 동작할지 고려
- TTL이 지나지 않은 콘텐츠에 대해서도 무효화하는 방법

### CDN, 캐시, 로드밸린서, 데이터 베이스와 서버 다중화
<img width="679" height="697" alt="스크린샷 2025-08-13 오후 5 37 15" src="https://github.com/user-attachments/assets/e245bff7-1167-4ccb-8580-e3660de9eba3" />

### 무상태 웹계층

웹 계층의 수평적 확장을 위해 상태 정보를 웹 계층에서 제거해야한다. 상태 정보를 관계형 DB나 NoSQL 같은 지속성 저장소에 보관하고 필요할때마다 가져오는게 바람직하다.

### 상태 정보 의존적인 아키텍처의 문제점
<img width="693" height="434" alt="스크린샷 2025-08-13 오후 5 37 45" src="https://github.com/user-attachments/assets/c8a28059-c43c-46da-b521-5bc95948281b" />

서버마다 상태 정보를 갖게 된다면 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야 한다는 문제가 생긴다. 대부분의 로드런서가 고정 세션이라는 기능을 제공하지만, 이는 로드밸린서에게 부담을 주고, 로드 밸린서 뒷단에 서버를 추가하거나 제거하기도 까다로워진다. 

이유 : 고정 세션은 트래픽을 세션 단위로 분배하기에, 특저 서버에만 세션이 몰리게 될 수도 있으며 새로운 웹 서버를 추가해도 오직 새로운 세션의 요청만 받게 되어 기존 서버들의 부하는 줄어들지 않는다.

### 무상태 아키텍처
<img width="642" height="695" alt="스크린샷 2025-08-13 오후 5 38 03" src="https://github.com/user-attachments/assets/e66cb9bd-42e5-4bfa-9e6e-5c79a7d4e7a9" />

웹 서버는 상태 정보가 필요할 경우 공유 저장소로부터 데이터를 가져온다. 상태정보는 물리적으로 웹서버와 분리되어 있다.

### CDN, 캐시, 로드밸린서, 데이터 베이스와 서버 다중화, 무상태 웹계층
<img width="677" height="620" alt="스크린샷 2025-08-13 오후 5 38 29" src="https://github.com/user-attachments/assets/7f4d4244-728a-4535-b79c-826923a05596" />

상태 정보를 Memecached/Redis 같은 캐시 시스템이나 NoSQL 에 저장할 수 있다.

### 데이터 센터

전 세계 사용자가 사용할 수 있게 하기 위해 geoDNS는 사용자 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지를 정한다.
<img width="689" height="630" alt="스크린샷 2025-08-13 오후 5 39 41" src="https://github.com/user-attachments/assets/8530af51-74d8-4919-b943-21d7ef1bf4b2" />

데이터 베이스간 동기화와, 지리상 가장 가까운 데이터 센터로 트래픽을 보낼 수 있도록 해야한다.

### 서버의 안정성과 확장성을 위한 메시지 큐

메시지 큐는 일단 보관된 메시지를 소비자가 꺼내 쓸 때까지 안전히 보관됨을 보장하는 비동기 통신을 지원하는 컴포넌트다. 

생산자가 메시지를 만들어 메시지 큐에 발행한다. 큐엔 보통 소비자가 연결되어 있고 소비자가 메시지를 받아 동작을 수행한다.
<img width="682" height="138" alt="스크린샷 2025-08-13 오후 5 39 56" src="https://github.com/user-attachments/assets/2c5469f9-12dd-41fe-8fd5-68a7a055600d" />

서비스 또는 서버 간 결합이 느슨해져서 규모 확장성이 보장되어야하는 안정적 어플리케이션을 구성하기 좋다

예를 들어 보정 어플리케이션을 만든다고 해보자.
<img width="689" height="194" alt="스크린샷 2025-08-13 오후 5 40 10" src="https://github.com/user-attachments/assets/12f528ac-d722-4d53-875b-785c7d1cd177" />

웹 서버는 보정 작업 큐에 보정 작업 ( job )을 넣고 소비자는 이 작업을 메시지 큐에서 꺼내 비동기적으로 완료한다.

만약 메시지 큐가 없었더라면, 웹 서버의 스레드나 프로세스는 다른 어떤 일도 하지 못하고 **'블로킹(blocking)'** 상태가 되고 웹 서버는 자원이 소진되어 새로운 요청을 받아들이지 못하고 서비스가 마비될 것이다.

cf ) 프론트엔드에서 API를 호출하는 비동기 처리는 이전 예시의 '사진 보정' 같은 무거운 연산 **'Job'이 아니라, 대표적인 'I/O-bound(입출력 위주)' 작업**이기 때문에 가능하다. 

### 로그, 메트릭, 자동화, 메시지큐,CDN, 캐시, 로드밸린서, 데이터 베이스와 서버 다중화, 무상태 웹계층
<img width="675" height="679" alt="스크린샷 2025-08-13 오후 5 40 24" src="https://github.com/user-attachments/assets/388bcbb2-37d2-4b54-9227-790ff7b06681" />

### 데이터베이스의 규모 확장

저장할 데이터가 많아지면 데이터 베이스 증설할 방법을 찾아야한다. 

- 수직적 확장은 하드웨어의 한계, SPOF 위험성, 비용 문제가 생긴다.
- 수평적 확장으론 샤딩이 있다.

### 샤딩
같은 스키마를 사용하지만 보관된 데이터 사이 중복은 없다. user_id%4 를 해시 함수로 사용하여 데이터가 보관되는 샤드를 정하는 것이 그 예시이다.
<img width="601" height="362" alt="스크린샷 2025-08-13 오후 5 40 39" src="https://github.com/user-attachments/assets/56e66222-7202-4cac-83ec-ede087a17d0e" />

### 샤딩시 고려할 사항

- 샤딩키 ( 파티션키 ) - 데이터를 고르게 분할 할 수 있도록 적절한 키를 선택하는게 중요하다 ( ex . user_id )
- 샤딩키로 인한 데이터 분포가 균등하지 못하다면, 사드 소진이 발생하고 재샤딩이 필요하다
- 특정 샤드에 질의가 집중되면 핫스팟키 문제가 발생한다
- 여러 샤드에 걸친 데이터를 조인하기 힘들다
  
<img width="683" height="727" alt="스크린샷 2025-08-13 오후 5 41 14" src="https://github.com/user-attachments/assets/0ed5cd8b-8383-4b7d-b3ad-f802aafe728d" />

### 시스템 규모 확장을 위해 살펴본 방법들 정리

- 웹계층은 무상태로
- 모든 계층에 다중화
- 읽기가 빈번한 데이터는 캐시
- 여러 데이터 센터
- 정적 컨텐츠는 CDN
- 각 계층을 독립적 서비스로 분할
- 로그, 모니터링, 자동화 도구 사용
